# FPGA蜂鸣器七音阶发生器说明文档

## 项目概述
本项目实现了一个基于FPGA的自动蜂鸣器音乐发生器，能够循环播放C大调的七个基本音阶（Do、Re、Mi、Fa、So、La、Si），每个音阶持续0.5秒。

## 模块接口

### 模块声明
```verilog
module beep
#(
    parameter COUNT_500MS = 25'd24_999_999,
    parameter DO = 190840,
    parameter RE = 170068,
    parameter MI = 151515,
    parameter FA = 143266,
    parameter SO = 127551,
    parameter LA = 113636,
    parameter XI = 101020
)
(
    input   wire  clk,    // 系统时钟（假设为50MHz）
    input   wire  rst,    // 复位信号（低电平有效）
    output  reg   beep    // 蜂鸣器驱动信号
);
```

### 端口说明
| 端口名 | 方向 | 位宽 | 描述 |
|--------|------|------|------|
| `clk` | 输入 | 1位 | 系统时钟输入，典型值为50MHz |
| `rst` | 输入 | 1位 | 异步复位信号，低电平有效 |
| `beep` | 输出 | 1位 | 蜂鸣器驱动信号输出，连接到无源蜂鸣器 |

## 参数定义

### 时间控制参数
- **COUNT_500MS** = 25'd24,999,999
  - 0.5秒计时器的计数值
  - 对于50MHz时钟：0.5秒 × 50,000,000 Hz = 25,000,000个时钟周期
  - 由于从0开始计数，实际使用24,999,999作为终值

### 音阶频率参数
| 参数名 | 值 | 对应频率 | 计算公式 |
|--------|-----|----------|----------|
| `DO` | 190,840 | 262Hz | 50M/(2×262)≈95,420 |
| `RE` | 170,068 | 294Hz | 50M/(2×294)≈85,034 |
| `MI` | 151,515 | 330Hz | 50M/(2×330)≈75,758 |
| `FA` | 143,266 | 349Hz | 50M/(2×349)≈71,633 |
| `SO` | 127,551 | 392Hz | 50M/(2×392)≈63,776 |
| `LA` | 113,636 | 440Hz | 50M/(2×440)≈56,818 |
| `XI` | 101,020 | 494Hz | 50M/(2×494)≈50,607 |

## 工作原理

### 2. 核心原理

1. **频率生成原理**：
   - 蜂鸣器音高由方波信号的频率决定
   - 每个音阶对应一个特定的频率（如Do=262Hz，Re=294Hz等）
   - 通过计算不同的分频系数，从系统时钟（50MHz）分频得到目标频率

2. **占空比控制**：
   - 使用50%占空比的方波驱动蜂鸣器
   - 占空比计算：`duty_data = freq_data >> 1`（右移1位，相当于除以2）

### 3. 主要寄存器说明

| 寄存器名 | 位宽 | 功能描述 |
|----------|------|----------|
| `cnt` | 25位 | 0.5秒计时器，控制每个音阶的持续时间 |
| `cnt_500ms` | 3位 | 音阶序号计数器（0-6），循环计数 |
| `freq_data` | 18位 | 当前音阶的分频系数 |
| `freq_cnt` | 18位 | 音频分频计数器，用于生成方波 |
| `beep` | 1位 | 蜂鸣器输出寄存器 |

## 详细工作流程

### 状态转移

#### 阶段1：0.5秒定时（控制音阶切换）
```verilog
// cnt从0计数到24,999,999（约0.5秒）
always@(posedge clk or negedge rst)
    if(rst == 1'b0)
        cnt <= 25'd0;
    else if(cnt == COUNT_500MS)
        cnt <= 25'd0;
    else
        cnt <= cnt + 1'b1;
```

#### 阶段2：音阶序号计数
```verilog
// cnt_500ms在每次cnt到达终值时加1，0-6循环
always@(posedge clk or negedge rst)
    if(rst == 1'b0)
        cnt_500ms <= 3'd0;
    else if(cnt == COUNT_500MS && cnt_500ms == 6)
        cnt_500ms <= 3'd0;
    else if(cnt == COUNT_500MS)
        cnt_500ms <= cnt_500ms + 1'b1;
```

#### 阶段3：选择当前音阶
```verilog
// 根据cnt_500ms选择对应的分频系数
always@(posedge clk or negedge rst)
    if(rst == 1'b0)
        freq_data <= DO;
    else case(cnt_500ms)
        0: freq_data <= DO;   // 第0-0.5秒：Do
        1: freq_data <= RE;   // 第0.5-1.0秒：Re
        2: freq_data <= MI;   // 第1.0-1.5秒：Mi
        3: freq_data <= FA;   // 第1.5-2.0秒：Fa
        4: freq_data <= SO;   // 第2.0-2.5秒：So
        5: freq_data <= LA;   // 第2.5-3.0秒：La
        6: freq_data <= XI;   // 第3.0-3.5秒：Si
    default: freq_data <= DO;
 endcase
```

#### 阶段4：音频分频计数器
```verilog
// 生成音频频率的分频计数器
always@(posedge clk or negedge rst)
    if(rst == 1'b0)
        freq_cnt <= 18'd0;
    else if(freq_cnt == freq_data || cnt == COUNT_500MS)
        freq_cnt <= 18'd0;
    else
        freq_cnt <= freq_cnt + 1'b1;
```

#### 阶段5：蜂鸣器输出生成
```verilog
// 输出50%占空比的方波
always@(posedge clk or negedge rst)
    if(rst == 1'b0)
        beep <= 1'b0;
    else if(freq_cnt < duty_data)  // 前半个周期输出高电平
        beep <= 1'b1;
    else                            // 后半个周期输出低电平
        beep <= 1'b0;
```

## 关键公式

### 1. 频率分频系数计算
```
分频系数 = 系统时钟频率 ÷ (2 × 目标频率)
N = f_clk ÷ (2 × f_tone)
```

对于50MHz时钟和262Hz的Do音：
```
N = 50,000,000 ÷ (2 × 262) ≈ 95,420
```

### 2. 方波周期计算
```
方波周期 = 2 × 分频系数 ÷ 系统时钟频率
T = 2 × N ÷ f_clk
```

### 3. 占空比控制
```
高电平时间 = 分频系数 × 占空比
对于50%占空比：高电平计数 = N ÷ 2
```
> **重要**：必须使用**无源蜂鸣器**，有源蜂鸣器只能发出固定频率的声音。